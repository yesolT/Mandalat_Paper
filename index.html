<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ë§Œë‹¤ë¼íŠ¸ í•™ìŠµì§€</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
    
    <style>
        body { font-family: 'Malgun Gothic', 'Apple SD Gothic Neo', sans-serif; }
        /* ìº”ë²„ìŠ¤ í„°ì¹˜ ìŠ¤í¬ë¡¤ ë°©ì§€ */
        canvas { touch-action: none; }
    </style>
</head>
<body class="bg-gray-100 text-gray-800">
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useRef, useEffect, useMemo } = React;

        // --- ì•„ì´ì½˜ ì»´í¬ë„ŒíŠ¸ (Lucide ëŒ€ì²´) ---
        const Icons = {
            Pencil: ({size}) => <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M17 3a2.85 2.83 0 1 1 4 4L7.5 20.5 2 22l1.5-5.5Z"/><path d="m15 5 4 4"/></svg>,
            Eraser: ({size}) => <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="m7 21-4.3-4.3c-1-1-1-2.5 0-3.4l9.6-9.6c1-1 2.5-1 3.4 0l5.6 5.6c1 1 1 2.5 0 3.4L13 21"/><path d="M22 21H7"/><path d="m5 11 9 9"/></svg>,
            RotateCcw: ({size}) => <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M3 12a9 9 0 1 0 9-9 9.75 9.75 0 0 0-6.74 2.74L3 8"/><path d="M3 3v5h5"/></svg>,
            Check: ({size}) => <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><polyline points="20 6 9 17 4 12"/></svg>,
            ChevronDown: ({size, className}) => <svg className={className} width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="m6 9 6 6 6-6"/></svg>,
            AlertCircle: ({size}) => <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><circle cx="12" cy="12" r="10"/><line x1="12" x2="12" y1="8" y2="12"/><line x1="12" x2="12.01" y1="16" y2="16"/></svg>,
            ImageIcon: ({size}) => <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><rect width="18" height="18" x="3" y="3" rx="2" ry="2"/><circle cx="9" cy="9" r="2"/><path d="m21 15-3.086-3.086a2 2 0 0 0-2.828 0L6 21"/></svg>,
            Loader2: ({size, className}) => <svg className={className} width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M21 12a9 9 0 1 1-6.219-8.56"/></svg>
        };

        // --- 1. ê·¸ë¦¼íŒ ì»´í¬ë„ŒíŠ¸ (ìƒ‰ìƒ ê¸°ëŠ¥ ì¶”ê°€ë¨) ---
        const DrawingCanvas = ({ width, height, className = "", placeholder = "ê·¸ë¦¼ì„ ê·¸ë ¤ë³´ì„¸ìš”" }) => {
            const canvasRef = useRef(null);
            const [isDrawing, setIsDrawing] = useState(false);
            const [mode, setMode] = useState('draw');
            const [color, setColor] = useState('#000000'); // ê¸°ë³¸ê°’: ê²€ì •

            const presetColors = ['#000000', '#FF0000', '#0000FF', '#008000', '#FFA500'];

            const getCoordinates = (event) => {
                if (!canvasRef.current) return { x: 0, y: 0 };
                const canvas = canvasRef.current;
                const rect = canvas.getBoundingClientRect();
                const scaleX = canvas.width / rect.width;
                const scaleY = canvas.height / rect.height;

                let clientX, clientY;
                if (event.touches) {
                    clientX = event.touches[0].clientX;
                    clientY = event.touches[0].clientY;
                } else {
                    clientX = event.clientX;
                    clientY = event.clientY;
                }

                return {
                    x: (clientX - rect.left) * scaleX,
                    y: (clientY - rect.top) * scaleY
                };
            };

            const startDrawing = (e) => {
                if (e.type === 'touchstart') document.body.style.overflow = 'hidden';
                const { x, y } = getCoordinates(e);
                const ctx = canvasRef.current?.getContext('2d');
                if (ctx) {
                    ctx.beginPath();
                    ctx.moveTo(x, y);
                    ctx.lineWidth = mode === 'draw' ? 2 : 15;
                    ctx.lineCap = 'round';
                    ctx.strokeStyle = mode === 'draw' ? color : '#fff'; // ì„ íƒëœ ìƒ‰ìƒ ì‚¬ìš©
                    setIsDrawing(true);
                }
            };

            const draw = (e) => {
                if (!isDrawing) return;
                const { x, y } = getCoordinates(e);
                const ctx = canvasRef.current?.getContext('2d');
                if (ctx) {
                    ctx.lineTo(x, y);
                    ctx.stroke();
                }
            };

            const stopDrawing = () => {
                if (isDrawing) {
                    const ctx = canvasRef.current?.getContext('2d');
                    ctx?.closePath();
                    setIsDrawing(false);
                    document.body.style.overflow = 'auto';
                }
            };

            const clearCanvas = () => {
                const canvas = canvasRef.current;
                const ctx = canvas?.getContext('2d');
                if (canvas && ctx) {
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                }
            };

            const handleColorChange = (newColor) => {
                setColor(newColor);
                setMode('draw');
            };

            useEffect(() => {
                const canvas = canvasRef.current;
                if (!canvas) return;
                const initCanvas = () => {
                    const parent = canvas.parentElement;
                    if (parent && parent.clientWidth > 0 && parent.clientHeight > 0) {
                        if (canvas.width !== (width || parent.clientWidth) || canvas.height !== (height || parent.clientHeight)) {
                            canvas.width = width || parent.clientWidth;
                            canvas.height = height || parent.clientHeight;
                        }
                    }
                };
                initCanvas();
                const timer = setTimeout(initCanvas, 100);
                return () => clearTimeout(timer);
            }, [width, height]);

            return (
                <div className={`relative group w-full h-full bg-white overflow-hidden ${className}`}>
                    {/* ë„êµ¬ & ìƒ‰ìƒ ì˜¤ë²„ë ˆì´ */}
                    <div className="absolute top-1 right-1 flex flex-col items-end gap-1 opacity-0 group-hover:opacity-100 transition-opacity z-10">
                        {/* ë„êµ¬ ë²„íŠ¼ë“¤ */}
                        <div className="flex gap-1 bg-white/90 p-1 rounded-lg shadow-sm border border-gray-200 backdrop-blur-sm">
                            <button onClick={() => setMode('draw')} className={`p-1 rounded ${mode === 'draw' ? 'bg-blue-100 text-blue-600' : 'hover:bg-gray-100 text-gray-600'}`} title="ê·¸ë¦¬ê¸°"><Icons.Pencil size={14} /></button>
                            <button onClick={() => setMode('erase')} className={`p-1 rounded ${mode === 'erase' ? 'bg-blue-100 text-blue-600' : 'hover:bg-gray-100 text-gray-600'}`} title="ì§€ìš°ê°œ"><Icons.Eraser size={14} /></button>
                            <button onClick={clearCanvas} className="p-1 rounded hover:bg-red-100 text-red-500" title="ì „ì²´ ì§€ìš°ê¸°"><Icons.RotateCcw size={14} /></button>
                        </div>
                        {/* ìƒ‰ìƒ ë²„íŠ¼ë“¤ */}
                        <div className="flex gap-1 bg-white/90 p-1 rounded-lg shadow-sm border border-gray-200 backdrop-blur-sm items-center">
                            {presetColors.map((c) => (
                                <button
                                    key={c}
                                    onClick={() => handleColorChange(c)}
                                    className={`w-4 h-4 rounded-full border border-gray-300 transition-transform hover:scale-110 ${color === c && mode === 'draw' ? 'ring-2 ring-blue-400 scale-110' : ''}`}
                                    style={{ backgroundColor: c }}
                                    title={c}
                                />
                            ))}
                            {/* ì»¤ìŠ¤í…€ ìƒ‰ìƒ ì„ íƒê¸° */}
                            <label className={`w-4 h-4 rounded-full border border-gray-300 overflow-hidden cursor-pointer flex items-center justify-center bg-gradient-to-br from-red-500 via-green-500 to-blue-500 hover:scale-110 transition-transform ${!presetColors.includes(color) && mode === 'draw' ? 'ring-2 ring-blue-400' : ''}`}>
                                <input 
                                    type="color" 
                                    value={color}
                                    onChange={(e) => handleColorChange(e.target.value)}
                                    className="opacity-0 w-full h-full cursor-pointer"
                                    title="ìƒ‰ìƒ ì„ íƒ"
                                />
                            </label>
                        </div>
                    </div>

                    <div className="absolute inset-0 flex items-center justify-center pointer-events-none text-gray-200 text-sm select-none">{placeholder}</div>
                    <canvas
                        ref={canvasRef}
                        onMouseDown={startDrawing}
                        onMouseMove={draw}
                        onMouseUp={stopDrawing}
                        onMouseLeave={stopDrawing}
                        onTouchStart={startDrawing}
                        onTouchMove={draw}
                        onTouchEnd={stopDrawing}
                        className="relative z-0 touch-none cursor-crosshair w-full h-full"
                    />
                </div>
            );
        };

        // --- 2. ì¤‘ì•™ 3x3 ê·¸ë¦¬ë“œ ---
        const CenterGrid = ({ mainTopic, setMainTopic, candidates, setCandidates, assignments, checkDuplicate }) => {
            const handleCandidateChange = (index, value) => {
                const newCandidates = [...candidates];
                newCandidates[index] = value;
                setCandidates(newCandidates);
            };

            const inputClass = "w-full h-full text-center p-2 text-sm sm:text-base resize-none focus:outline-none focus:bg-blue-50 bg-transparent placeholder-gray-300";
            const cellClass = "border border-gray-300 bg-white relative overflow-hidden aspect-square flex flex-col";

            const getAssignedLabel = (index) => {
                if (assignments.tl === index) return "â†–";
                if (assignments.tr === index) return "â†—";
                if (assignments.bl === index) return "â†™";
                if (assignments.br === index) return "â†˜";
                return null;
            };

            const renderCandidateCell = (index, placeholderNum) => {
                const assignedLabel = getAssignedLabel(index);
                const isAssigned = assignedLabel !== null;
                const value = candidates[index];
                const isDup = checkDuplicate(value);

                return (
                    <div className={`${cellClass} ${isAssigned ? 'bg-yellow-50 ring-2 ring-inset ring-yellow-200' : ''} ${isDup ? 'ring-2 ring-inset ring-red-500 bg-red-50' : ''}`}>
                        {isDup && (
                            <div className="absolute top-0 left-0 bg-red-500 text-white text-[9px] px-1 rounded-br z-20 flex items-center gap-0.5">
                                <Icons.AlertCircle size={8} /> ì¤‘ë³µ
                            </div>
                        )}
                        <textarea 
                            className={inputClass} 
                            placeholder={`ë‹¨ì–´ ${placeholderNum}`}
                            value={value}
                            onChange={(e) => handleCandidateChange(index, e.target.value)}
                        />
                        {isAssigned && !isDup && (
                            <div className="absolute top-1 right-1 text-xs font-bold text-blue-500 bg-blue-100 rounded-full w-5 h-5 flex items-center justify-center select-none">
                                {assignedLabel}
                            </div>
                        )}
                    </div>
                );
            };

            const isMainDup = checkDuplicate(mainTopic);

            return (
                <div className="grid grid-cols-3 grid-rows-3 w-full h-full border-2 border-gray-800 shadow-lg">
                    {renderCandidateCell(0, 1)}
                    {renderCandidateCell(1, 2)}
                    {renderCandidateCell(2, 3)}
                    {renderCandidateCell(3, 4)}
                    
                    <div className={`${cellClass} bg-blue-100 border-2 border-blue-300 z-10 ${isMainDup ? 'ring-2 ring-inset ring-red-500' : ''}`}>
                        {isMainDup && (
                            <div className="absolute top-0 left-0 bg-red-500 text-white text-[9px] px-1 rounded-br z-20 flex items-center gap-0.5">
                                <Icons.AlertCircle size={8} /> ì¤‘ë³µ
                            </div>
                        )}
                        <textarea 
                            className={`${inputClass} font-bold text-lg bg-transparent placeholder-blue-300 whitespace-pre-wrap break-keep`} 
                            placeholder={`í•µì‹¬\nì£¼ì œ`}
                            value={mainTopic}
                            onChange={(e) => setMainTopic(e.target.value)}
                        />
                    </div>

                    {renderCandidateCell(4, 5)}
                    {renderCandidateCell(5, 6)}
                    {renderCandidateCell(6, 7)}
                    {renderCandidateCell(7, 8)}
                </div>
            );
        };

        // --- 3. í™•ì¥ ê·¸ë¦¬ë“œ ---
        const ExpansionGrid = ({ positionKey, assignments, setAssignments, candidates, gridData, onUpdateGrid, checkDuplicate }) => {
            const cellClass = "border border-gray-200 bg-white aspect-square flex items-center justify-center relative";
            const inputClass = "w-full h-full text-center p-1 text-xs resize-none focus:outline-none focus:bg-yellow-50 bg-transparent placeholder-gray-200";

            const assignedIndex = assignments[positionKey];
            const centerText = assignedIndex !== null ? candidates[assignedIndex] : "";

            const handleSelect = (e) => {
                const val = e.target.value;
                setAssignments(prev => ({
                    ...prev,
                    [positionKey]: val === "" ? null : Number(val)
                }));
            };

            const renderSurroundingCells = () => {
                const cells = [];
                for (let i = 0; i < 9; i++) {
                    if (i === 4) {
                        cells.push(
                            <div key={i} className={`${cellClass} bg-yellow-100 font-semibold text-sm border-yellow-300 group`}>
                                {assignedIndex === null ? (
                                    <div className="absolute inset-0 flex items-center justify-center opacity-50 group-hover:opacity-100">
                                        <span className="text-gray-400 text-[10px] text-center px-1">í´ë¦­í•˜ì—¬<br/>ë‹¨ì–´ ì„ íƒ</span>
                                    </div>
                                ) : (
                                    <div className="w-full text-center break-words px-1 z-0">
                                        {centerText || <span className="text-red-300 text-[10px]">(ë¹„ì–´ìˆìŒ)</span>}
                                    </div>
                                )}
                                <select 
                                    className="absolute inset-0 w-full h-full opacity-0 cursor-pointer z-10"
                                    value={assignedIndex !== null ? assignedIndex : ""}
                                    onChange={handleSelect}
                                >
                                    <option value="">(ì„ íƒ ì•ˆí•¨)</option>
                                    {candidates.map((text, idx) => (
                                        <option key={idx} value={idx}>{idx + 1}. {text || "(ë¹„ì–´ìˆìŒ)"}</option>
                                    ))}
                                </select>
                                <div className="absolute top-0 right-0 p-0.5 pointer-events-none">
                                    <Icons.ChevronDown size={10} className="text-gray-400" />
                                </div>
                            </div>
                        );
                    } else {
                        const value = gridData[i];
                        const isDup = checkDuplicate(value);
                        cells.push(
                            <div key={i} className={`${cellClass} ${isDup ? 'ring-2 ring-inset ring-red-500 bg-red-50' : ''}`}>
                                {isDup && (
                                    <div className="absolute top-0 left-0 bg-red-500 text-white text-[8px] px-1 rounded-br z-20">ì¤‘ë³µ</div>
                                )}
                                <textarea 
                                    className={inputClass} 
                                    placeholder="ìƒê°" 
                                    value={value}
                                    onChange={(e) => onUpdateGrid(i, e.target.value)}
                                />
                            </div>
                        );
                    }
                }
                return cells;
            };

            return (
                <div className="grid grid-cols-3 grid-rows-3 w-full h-full border border-gray-400">
                    {renderSurroundingCells()}
                </div>
            );
        };

        // --- 4. í° ê·¸ë¦¼íŒ ---
        const LargeDrawingArea = ({ label }) => {
            return (
                <div className="w-full h-full border border-dashed border-gray-300 bg-gray-50 flex flex-col items-center justify-center p-2">
                    <div className="w-full h-full bg-white shadow-inner border border-gray-200 relative">
                        <DrawingCanvas placeholder={label} />
                    </div>
                </div>
            );
        };

        // --- ë©”ì¸ ì•± ---
        function MandalartApp() {
            const [mainTopic, setMainTopic] = useState("");
            const [candidates, setCandidates] = useState(Array(8).fill(""));
            const [assignments, setAssignments] = useState({ tl: null, tr: null, bl: null, br: null });
            const [expansionData, setExpansionData] = useState({
                tl: Array(9).fill(""), tr: Array(9).fill(""), bl: Array(9).fill(""), br: Array(9).fill("")
            });
            const [date, setDate] = useState("");
            const [name, setName] = useState("");
            const [isSaving, setIsSaving] = useState(false);
            const printRef = useRef(null);

            const handleSaveImage = async () => {
                if (!printRef.current || !window.html2canvas) return;
                setIsSaving(true);
                try {
                    await new Promise(resolve => setTimeout(resolve, 100));
                    const element = printRef.current;
                    const canvas = await window.html2canvas(element, {
                        scale: 2, 
                        useCORS: true, 
                        backgroundColor: '#ffffff', 
                        logging: false,
                        onclone: (clonedDoc) => {
                            const clonedContainer = clonedDoc.querySelector('[data-print-container="true"]');
                            if (clonedContainer) {
                                clonedContainer.classList.remove('shadow-xl', 'rounded-xl');
                                clonedContainer.style.aspectRatio = 'auto';
                                clonedContainer.style.height = 'auto';
                            }
                            
                            // Input ìš”ì†Œë“¤ì„ í…ìŠ¤íŠ¸ divë¡œ êµì²´ (ì´ë¯¸ì§€ ì €ì¥ ì‹œ ì˜ë¦¼ ë°©ì§€)
                            const originalInputs = element.querySelectorAll('input');
                            const clonedInputs = clonedDoc.querySelectorAll('input');
                            
                            originalInputs.forEach((input, i) => {
                                const clonedInput = clonedInputs[i];
                                if (clonedInput && clonedInput.parentNode) {
                                    const textDiv = clonedDoc.createElement('div');
                                    textDiv.textContent = input.value;
                                    textDiv.style.borderBottom = '1px solid #9ca3af';
                                    textDiv.style.textAlign = 'center';
                                    textDiv.style.display = 'inline-block';
                                    textDiv.style.fontSize = '12px';
                                    textDiv.style.color = '#374151';
                                    
                                    if (input.classList.contains('w-32')) textDiv.style.width = '128px';
                                    else if (input.classList.contains('w-24')) textDiv.style.width = '96px';
                                    else textDiv.style.width = '100px';
                                    
                                    clonedInput.parentNode.replaceChild(textDiv, clonedInput);
                                }
                            });

                            const originalTextareas = element.querySelectorAll('textarea');
                            const clonedTextareas = clonedDoc.querySelectorAll('textarea');
                            originalTextareas.forEach((ta, i) => {
                                if (clonedTextareas[i]) {
                                    clonedTextareas[i].value = ta.value;
                                    clonedTextareas[i].innerHTML = ta.value; 
                                }
                            });
                        }
                    });

                    const image = canvas.toDataURL("image/png");
                    const link = document.createElement("a");
                    link.href = image;
                    link.download = `ë§Œë‹¤ë¼íŠ¸_${mainTopic || 'í•™ìŠµì§€'}_${new Date().toLocaleDateString()}.png`;
                    link.click();
                } catch (err) {
                    console.error("Save failed:", err);
                    alert("ì´ë¯¸ì§€ ì €ì¥ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.");
                } finally {
                    setIsSaving(false);
                }
            };

            const updateExpansionGrid = (key, index, value) => {
                setExpansionData(prev => {
                    const newData = [...prev[key]];
                    newData[index] = value;
                    return { ...prev, [key]: newData };
                });
            };

            const allValues = useMemo(() => {
                const values = [
                    mainTopic,
                    ...candidates,
                    ...expansionData.tl.filter((_, i) => i !== 4),
                    ...expansionData.tr.filter((_, i) => i !== 4),
                    ...expansionData.bl.filter((_, i) => i !== 4),
                    ...expansionData.br.filter((_, i) => i !== 4),
                ];
                return values.filter(v => v && v.trim() !== "");
            }, [mainTopic, candidates, expansionData]);

            const checkDuplicate = (text) => {
                if (!text || text.trim() === "") return false;
                const count = allValues.filter(v => v.trim() === text.trim()).length;
                return count > 1;
            };

            return (
                <div className="min-h-screen bg-gray-100 p-2 sm:p-4 font-sans text-gray-800">
                    <div className="max-w-5xl mx-auto">
                        <header className="mb-4 sm:mb-6 flex flex-col sm:flex-row justify-between items-center bg-white p-4 rounded-xl shadow-sm gap-4">
                            <div>
                                <h1 className="text-xl sm:text-2xl font-bold text-gray-800">ë§Œë‹¤ë¼íŠ¸ í•™ìŠµì§€</h1>
                                <p className="text-xs sm:text-sm text-gray-500 mt-1">
                                    í•µì‹¬ ì£¼ì œì™€ ê´€ë ¨ëœ 8ê°€ì§€ ë– ì˜¤ë¥´ëŠ” ë‹¨ì–´ë¥¼ ì ê³ , ê·¸ ì¤‘ 4ê°€ì§€ë¥¼ ê³¨ë¼ ìƒê°ì„ í™•ì¥ì‹œì¼œë³´ì„¸ìš”. <br />
                                    <span className="text-red-500 font-bold">* ì¤‘ë³µëœ ìƒê°ì€ í‘œì‹œë©ë‹ˆë‹¤.</span>
                                </p>
                            </div>
                            <button 
                                onClick={handleSaveImage}
                                disabled={isSaving}
                                className="w-full sm:w-auto flex items-center justify-center gap-2 px-4 py-2 bg-blue-600 text-white rounded-lg hover:bg-blue-700 transition-colors shadow-sm disabled:opacity-50 disabled:cursor-not-allowed"
                            >
                                {isSaving ? <Icons.Loader2 className="animate-spin" size={18} /> : <Icons.ImageIcon size={18} />}
                                <span className="inline">{isSaving ? 'ì €ì¥ ì¤‘...' : 'ì´ë¯¸ì§€ íŒŒì¼ë¡œ ì €ì¥'}</span>
                            </button>
                        </header>

                        <div className="bg-yellow-50 p-4 rounded-xl border border-yellow-100 mb-4 sm:mb-6 text-sm text-yellow-800">
                            <h3 className="font-bold mb-2 flex items-center gap-2">ğŸ’¡ ì‚¬ìš© íŒ</h3>
                            <ul className="list-disc list-inside space-y-1 ml-1">
                                <li>ê°€ì¥ ì¤‘ì‹¬ ì¹¸ì— í•µì‹¬ ì£¼ì œë¥¼ ì ê³ , ì£¼ë³€ 8ì¹¸ì„ ì±„ì›Œë³´ì„¸ìš”.</li>
                                <li>ëª¨ì„œë¦¬ í‘œì˜ ë…¸ë€ ì¤‘ì•™ ì¹¸ì„ í´ë¦­í•´ ìƒê°ì„ í™•ì¥ ì‹œí‚¬ ë‹¨ì–´ë¥¼ ì„ íƒí•˜ì„¸ìš”.</li>
                                <li>ê·¸ë¦¼íŒì— ë§ˆìš°ìŠ¤ë¥¼ ì˜¬ë¦¬ë©´ <strong>ìƒ‰ìƒ íŒ”ë ˆíŠ¸</strong>ê°€ ë‚˜íƒ€ë‚©ë‹ˆë‹¤. íŒ”ë ˆíŠ¸ì— ì—†ëŠ” ìƒ‰ìƒì€ ìƒ‰ìƒ ì„ íƒ ë„êµ¬(ë¬´ì§€ê°œ ì›)ë¥¼ ì´ìš©í•´ ììœ ë¡­ê²Œ ë°”ê¿€ ìˆ˜ ìˆìŠµë‹ˆë‹¤.</li>
                                <li>ë‹¤ ì‘ì„±í•œ í›„ ìš°ì¸¡ ìƒë‹¨ì˜ <strong>[ì´ë¯¸ì§€ íŒŒì¼ë¡œ ì €ì¥]</strong> ë²„íŠ¼ì„ ëˆ„ë¥´ë©´ ê·¸ë¦¼ê³¼ ê¸€ì´ ëª¨ë‘ ì €ì¥ë©ë‹ˆë‹¤.</li>
                            </ul>
                        </div>

                        <div 
                            ref={printRef}
                            data-print-container="true"
                            className="bg-white p-6 shadow-xl rounded-xl w-full aspect-[1/1.2] sm:aspect-square flex flex-col"
                        >
                            <div className="text-center mb-4">
                                <h2 className="text-2xl font-bold border-b-2 border-gray-800 pb-2 inline-block">ë‚˜ì˜ ìƒê° í™•ì¥í•˜ê¸°</h2>
                            </div>
                            <div className="flex-1 grid grid-cols-3 grid-rows-3 gap-2 sm:gap-4">
                                <div className="w-full h-full overflow-hidden">
                                    <ExpansionGrid positionKey="tl" assignments={assignments} setAssignments={setAssignments} candidates={candidates} gridData={expansionData.tl} onUpdateGrid={(idx, val) => updateExpansionGrid('tl', idx, val)} checkDuplicate={checkDuplicate} />
                                </div>
                                <div className="w-full h-full overflow-hidden">
                                    <LargeDrawingArea label="ììœ  ê·¸ë¦¼ ê³µê°„ 1" />
                                </div>
                                <div className="w-full h-full overflow-hidden">
                                    <ExpansionGrid positionKey="tr" assignments={assignments} setAssignments={setAssignments} candidates={candidates} gridData={expansionData.tr} onUpdateGrid={(idx, val) => updateExpansionGrid('tr', idx, val)} checkDuplicate={checkDuplicate} />
                                </div>
                                <div className="w-full h-full overflow-hidden">
                                    <LargeDrawingArea label="ììœ  ê·¸ë¦¼ ê³µê°„ 2" />
                                </div>
                                <div className="w-full h-full overflow-hidden transform scale-100 origin-center">
                                    <CenterGrid mainTopic={mainTopic} setMainTopic={setMainTopic} candidates={candidates} setCandidates={setCandidates} assignments={assignments} checkDuplicate={checkDuplicate} />
                                </div>
                                <div className="w-full h-full overflow-hidden">
                                    <LargeDrawingArea label="ììœ  ê·¸ë¦¼ ê³µê°„ 3" />
                                </div>
                                <div className="w-full h-full overflow-hidden">
                                    <ExpansionGrid positionKey="bl" assignments={assignments} setAssignments={setAssignments} candidates={candidates} gridData={expansionData.bl} onUpdateGrid={(idx, val) => updateExpansionGrid('bl', idx, val)} checkDuplicate={checkDuplicate} />
                                </div>
                                <div className="w-full h-full overflow-hidden">
                                    <LargeDrawingArea label="ììœ  ê·¸ë¦¼ ê³µê°„ 4" />
                                </div>
                                <div className="w-full h-full overflow-hidden">
                                    <ExpansionGrid positionKey="br" assignments={assignments} setAssignments={setAssignments} candidates={candidates} gridData={expansionData.br} onUpdateGrid={(idx, val) => updateExpansionGrid('br', idx, val)} checkDuplicate={checkDuplicate} />
                                </div>
                            </div>
                            <div className="mt-4 flex justify-end items-center gap-4 text-xs text-gray-500 font-medium">
                                <div className="flex items-center gap-2">
                                    <span>ë‚ ì§œ:</span>
                                    <input 
                                        type="text" 
                                        value={date}
                                        onChange={(e) => setDate(e.target.value)}
                                        className="border-b border-gray-400 bg-transparent text-center w-32 focus:outline-none focus:border-blue-500 transition-colors" 
                                        placeholder="YYYY.MM.DD" 
                                    />
                                </div>
                                <div className="flex items-center gap-2">
                                    <span>ì´ë¦„:</span>
                                    <input 
                                        type="text" 
                                        value={name}
                                        onChange={(e) => setName(e.target.value)}
                                        className="border-b border-gray-400 bg-transparent text-center w-24 focus:outline-none focus:border-blue-500 transition-colors" 
                                        placeholder="ì´ë¦„ ì…ë ¥" 
                                    />
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            );
        }

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<MandalartApp />);
    </script>
</body>
</html>

